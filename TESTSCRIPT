local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local guiParent = player:WaitForChild("PlayerGui")

if guiParent:FindFirstChild("RayfieldMagnet") then
	guiParent.RayfieldMagnet:Destroy()
end

-- ===== VARIABLES =====
local magnetActive = false
local activationRange = 10

local jumpPowerActive = false
local jumpBoostForce = 50
local jumpBoostForceMin = 50
local jumpBoostForceMax = 65

local hitboxVisualActive = false
local autoCatchActive = false

local humanoid = nil
local hrp = nil
local lastCatch = 0
local hitboxParts = {}

local function clamp(n, a, b)
	return math.min(math.max(n, a), b)
end

-- ===== SPEED BOOST VARIABLES (ADDED) =====
local speedBoostActive = false
local speedBoostForce = 3
local speedBoostMin = 1
local speedBoostMax = 3

local originalAnimSpeed = {} -- stores original animation speeds per AnimationId

-- ===== GUI =====
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "RayfieldMagnet"
screenGui.ResetOnSpawn = false
screenGui.Parent = guiParent
screenGui.DisplayOrder = 1000

local card = Instance.new("Frame")
card.Name = "Card"
card.Size = UDim2.new(0, 360, 0, 346)
card.Position = UDim2.new(0, 40, 0, 120)
card.BackgroundColor3 = Color3.fromRGB(24, 24, 24)
card.BorderSizePixel = 0
card.Parent = screenGui
card.ClipsDescendants = false
Instance.new("UICorner", card).CornerRadius = UDim.new(0, 8)
local cardStroke = Instance.new("UIStroke", card)
cardStroke.Color = Color3.fromRGB(255, 255, 255)
cardStroke.Thickness = 2.5
local cardGradient = Instance.new("UIGradient", card)
cardGradient.Color = ColorSequence.new(Color3.fromRGB(185, 0, 0), Color3.fromRGB(0, 143, 0))
local cardstrokeGradient = Instance.new("UIGradient", cardStroke)
cardstrokeGradient.Color = ColorSequence.new(Color3.fromRGB(185, 0, 0), Color3.fromRGB(0, 143, 0))

-- Title Bar
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 38)
titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
titleBar.BorderSizePixel = 0
titleBar.Parent = card
Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 8)
local titleGradient = Instance.new("UIGradient", titleBar)
titleGradient.Color = ColorSequence.new(Color3.fromRGB(185, 0, 0), Color3.fromRGB(0, 143, 0))

local titleLabel = Instance.new("TextLabel", titleBar)
titleLabel.Size = UDim2.new(1, -112, 1, 0)
titleLabel.Position = UDim2.new(0, 16, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextSize = 18
titleLabel.TextColor3 = Color3.fromRGB(230, 230, 230)
titleLabel.Text = "ðŸŽ„ðŸŽ… 0UncStatus - FF2 Script ðŸŽ…ðŸŽ„"
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.TextYAlignment = Enum.TextYAlignment.Center

local arrow = Instance.new("TextButton", titleBar)
arrow.Size = UDim2.new(0, 38, 1, 0)
arrow.Position = UDim2.new(1, -38, 0, 0)
arrow.BackgroundTransparency = 1
arrow.Font = Enum.Font.Gotham
arrow.TextSize = 20
arrow.TextColor3 = Color3.fromRGB(180, 180, 180)
arrow.Text = "^"
arrow.TextXAlignment = Enum.TextXAlignment.Center
arrow.TextYAlignment = Enum.TextYAlignment.Center
arrow.AutoButtonColor = false
arrow.ZIndex = 10

-- Sections container
local sectionsContainer = Instance.new("ScrollingFrame", card)
sectionsContainer.Name = "Sections"
sectionsContainer.Position = UDim2.new(0, 0, 0, 38)
sectionsContainer.Size = UDim2.new(1, 0, 1, -38)
sectionsContainer.BackgroundTransparency = 1
sectionsContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
sectionsContainer.ScrollBarThickness = 6
sectionsContainer.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar
sectionsContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
sectionsContainer.ClipsDescendants = true
sectionsContainer.ZIndex = 1

local list = Instance.new("UIListLayout", sectionsContainer)
list.SortOrder = Enum.SortOrder.LayoutOrder
list.Padding = UDim.new(0, 1)

-- Section helper
local function MakeSection(parent, titleText)
	local section = Instance.new("Frame", parent)
	section.Size = UDim2.new(1, 0, 0, 84)
	section.BackgroundTransparency = 1
	section.LayoutOrder = 1

	local header = Instance.new("TextButton", section)
	header.Size = UDim2.new(0.933, 0, 0, 28)
	header.Position = UDim2.new(0, 12, 0, 6)
	header.BackgroundColor3 = Color3.fromRGB(67, 0, 0)
	header.BorderSizePixel = 0
	header.Text = titleText
	header.Font = Enum.Font.GothamBold
	header.TextSize = 14
	header.TextColor3 = Color3.fromRGB(230, 230, 2730)
	header.AutoButtonColor = true
	header.TextXAlignment = Enum.TextXAlignment.Left
	Instance.new("UICorner", header).CornerRadius = UDim.new(0, 6)

	local content = Instance.new("Frame", section)
	-- default content size (single row) â€” caller may resize
	content.Size = UDim2.new(1, -24, 0, 46)
	content.Position = UDim2.new(0, 12, 0, 34)
	content.BackgroundTransparency = 1
	content.ClipsDescendants = true




	return section, header, content
end

-- Magnet Section
local magnetSection, magnetHeader, magnetContent = MakeSection(sectionsContainer, "Mag")
magnetSection.LayoutOrder = 1
magnetContent.Size = UDim2.new(1, -24, 0, 34+25)

local autoCatchBtn = Instance.new("TextButton", magnetContent)
autoCatchBtn.Size = UDim2.new(0, 150, 0, 36)
autoCatchBtn.Position = UDim2.new(0, 160, 0, 12)
autoCatchBtn.BackgroundColor3 = Color3.fromRGB(54, 0, 0)
autoCatchBtn.BorderSizePixel = 0
autoCatchBtn.Font = Enum.Font.GothamBold
autoCatchBtn.TextSize = 20
autoCatchBtn.TextColor3 = Color3.new(1, 1, 1)
autoCatchBtn.Text = "MS OFF"
autoCatchBtn.TextScaled = true
autoCatchBtn.AutoButtonColor = true
Instance.new("UICorner", autoCatchBtn).CornerRadius = UDim.new(0, 6)

-- Activation Range Input
local numLabel = Instance.new("TextLabel", magnetContent)
numLabel.Size = UDim2.new(0, 120, 0, 18)
numLabel.Position = UDim2.new(0, 25, 0, 6)
numLabel.BackgroundTransparency = 1
numLabel.Font = Enum.Font.GothamBold
numLabel.TextSize = 14
numLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
numLabel.Text = "Activation Range"

local inputBox = Instance.new("TextBox", magnetContent)
inputBox.Size = UDim2.new(0, 60, 0, 26)
inputBox.Position = UDim2.new(0, 50, 0, 26)
inputBox.BackgroundColor3 = Color3.fromRGB(24, 76, 36)
inputBox.BorderSizePixel = 0
inputBox.PlaceholderText = "3-20"
inputBox.Font = Enum.Font.JosefinSans
inputBox.TextSize = 18
inputBox.TextColor3 = Color3.fromRGB(230, 230, 230)
inputBox.Text = tostring(activationRange)
inputBox.ClearTextOnFocus = false
inputBox.TextXAlignment = Enum.TextXAlignment.Center
Instance.new("UICorner", inputBox).CornerRadius = UDim.new(0, 6)

-- Player Section
local playerSection, playerHeader, playerContent = MakeSection(sectionsContainer, "Player")
playerSection.LayoutOrder = 2
-- Increase content height so both Jump Power & Speed Boost fit
playerContent.Size = UDim2.new(1, -24, 0, 92)

local jumpToggleBtn = Instance.new("TextButton", playerContent)
jumpToggleBtn.Size = UDim2.new(0, 150, 0, 36)
jumpToggleBtn.Position = UDim2.new(0, 0, 0, 4)
jumpToggleBtn.BackgroundColor3 = Color3.fromRGB(54, 0, 0)
jumpToggleBtn.BorderSizePixel = 0
jumpToggleBtn.Font = Enum.Font.GothamBold
jumpToggleBtn.TextSize = 20
jumpToggleBtn.TextColor3 = Color3.new(1, 1, 1)
jumpToggleBtn.Text = "Jump Power OFF"
jumpToggleBtn.TextScaled = true
jumpToggleBtn.AutoButtonColor = true
Instance.new("UICorner", jumpToggleBtn).CornerRadius = UDim.new(0, 6)

local jumpNumLabel = Instance.new("TextLabel", playerContent)
jumpNumLabel.Size = UDim2.new(0, 120, 0, 18)
jumpNumLabel.Position = UDim2.new(0, 162, 0, 6)
jumpNumLabel.BackgroundTransparency = 1
jumpNumLabel.Font = Enum.Font.GothamBold
jumpNumLabel.TextSize = 14
jumpNumLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
jumpNumLabel.Text = "Jump Power"

local jumpInputBox = Instance.new("TextBox", playerContent)
jumpInputBox.Size = UDim2.new(0, 60, 0, 26)
jumpInputBox.Position = UDim2.new(0, 162, 0, 26)
jumpInputBox.BackgroundColor3 = Color3.fromRGB(24, 76, 36)
jumpInputBox.BorderSizePixel = 0
jumpInputBox.PlaceholderText = "50-65"
jumpInputBox.Font = Enum.Font.JosefinSans
jumpInputBox.TextSize = 18
jumpInputBox.TextColor3 = Color3.fromRGB(230, 230, 230)
jumpInputBox.Text = tostring(jumpBoostForce)
jumpInputBox.ClearTextOnFocus = false
jumpInputBox.TextXAlignment = Enum.TextXAlignment.Center
Instance.new("UICorner", jumpInputBox).CornerRadius = UDim.new(0, 6)

-- ===== SPEED BOOST UI (ADDED, Option A: under Jump Power) =====
local speedBoostBtn = Instance.new("TextButton", playerContent)
speedBoostBtn.Size = UDim2.new(0, 150, 0, 36)
speedBoostBtn.Position = UDim2.new(0, 0, 0, 46)
speedBoostBtn.BackgroundColor3 = Color3.fromRGB(54, 0, 0)
speedBoostBtn.BorderSizePixel = 0
speedBoostBtn.Font = Enum.Font.GothamBold
speedBoostBtn.TextSize = 20
speedBoostBtn.TextColor3 = Color3.new(1, 1, 1)
speedBoostBtn.Text = "Speed Boost OFF"
speedBoostBtn.TextScaled = true
speedBoostBtn.AutoButtonColor = true
Instance.new("UICorner", speedBoostBtn).CornerRadius = UDim.new(0, 6)

local speedNumLabel = Instance.new("TextLabel", playerContent)
speedNumLabel.Size = UDim2.new(0, 120, 0, 18)
speedNumLabel.Position = UDim2.new(0, 162, 0, 48)
speedNumLabel.BackgroundTransparency = 1
speedNumLabel.Font = Enum.Font.GothamBold
speedNumLabel.TextSize = 14
speedNumLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
speedNumLabel.Text = "Boost Amount (1â€“3)"

local speedInputBox = Instance.new("TextBox", playerContent)
speedInputBox.Size = UDim2.new(0, 60, 0, 26)
speedInputBox.Position = UDim2.new(0, 162, 0, 66)
speedInputBox.BackgroundColor3 = Color3.fromRGB(24, 76, 36)
speedInputBox.BorderSizePixel = 0
speedInputBox.Font = Enum.Font.JosefinSans
speedInputBox.TextSize = 18
speedInputBox.TextColor3 = Color3.fromRGB(230, 230, 230)
speedInputBox.Text = tostring(speedBoostForce)
speedInputBox.ClearTextOnFocus = false
speedInputBox.TextXAlignment = Enum.TextXAlignment.Center
Instance.new("UICorner", speedInputBox).CornerRadius = UDim.new(0, 6)

-- ESP Section
local espSection, espHeader, espContent = MakeSection(sectionsContainer, "ESP")
espSection.LayoutOrder = 3

local hitboxToggleBtn = Instance.new("TextButton", espContent)
hitboxToggleBtn.Size = UDim2.new(0, 150, 0, 36)
hitboxToggleBtn.Position = UDim2.new(0, 0, 0, 4)
hitboxToggleBtn.BackgroundColor3 = Color3.fromRGB(54, 0, 0)
hitboxToggleBtn.BorderSizePixel = 0
hitboxToggleBtn.Font = Enum.Font.GothamBold
hitboxToggleBtn.TextSize = 20
hitboxToggleBtn.TextColor3 = Color3.new(1, 1, 1)
hitboxToggleBtn.Text = "Hitbox Visual OFF"
hitboxToggleBtn.TextScaled = true
hitboxToggleBtn.AutoButtonColor = true
Instance.new("UICorner", hitboxToggleBtn).CornerRadius = UDim.new(0, 6)

-- ===== SECTION TOGGLE FUNCTION =====
local function toggleSection(header, content)
	local open = false
	content.Visible = open
	header.Parent.Size = UDim2.new(1, 0, 0, 34)
	header.MouseButton1Click:Connect(function()
		open = not open
		content.Visible = open
		if open then
			if header == playerHeader then
				header.Parent.Size = UDim2.new(1, 0, 0, 120)
			else
				header.Parent.Size = UDim2.new(1, 0, 0, 84)
			end
		else
			header.Parent.Size = UDim2.new(1, 0, 0, 34)
		end
	end)
end
toggleSection(magnetHeader, magnetContent)
toggleSection(playerHeader, playerContent)
toggleSection(espHeader, espContent)

-- ===== DRAGGING LOGIC =====
local dragging = false
local dragInput, dragStart, startPos
titleBar.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = card.Position

		if input.UserInputType == Enum.UserInputType.Touch then
			ContextActionService:BindActionAtPriority("DisableCameraWhileDragging", function() return Enum.ContextActionResult.Sink end, false, 301)
		end

		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
				if input.UserInputType == Enum.UserInputType.Touch then
					ContextActionService:UnbindAction("DisableCameraWhileDragging")
				end
			end
		end)
	end
end)

titleBar.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		dragInput = input
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if input == dragInput and dragging then
		local delta = input.Position - dragStart
		card.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X,
			startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
end)

-- ===== COLLAPSE =====
local collapsed = false
local collapseTweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
local function collapseToggle()
	collapsed = not collapsed
	if collapsed then
		arrow.Text = "v"
		TweenService:Create(sectionsContainer, collapseTweenInfo, {Size = UDim2.new(1, 0, 0, 0)}):Play()
		TweenService:Create(card, collapseTweenInfo, {Size = UDim2.new(0, 360, 0, 38)}):Play()
	else
		arrow.Text = "^"
		TweenService:Create(sectionsContainer, collapseTweenInfo, {Size = UDim2.new(1, 0, 1, -38)}):Play()
		TweenService:Create(card, collapseTweenInfo, {Size = UDim2.new(0, 360, 0, 346)}):Play()
	end
end

arrow.MouseButton1Click:Connect(collapseToggle)

-- ===== CHARACTER SETUP =====
local function setupCharacter(character)
	humanoid = character:WaitForChild("Humanoid")
	hrp = character:WaitForChild("HumanoidRootPart")
end
if player.Character then setupCharacter(player.Character) end
player.CharacterAdded:Connect(setupCharacter)

-- ===== JUMP BOOST =====
local function applyJumpBoost(old, new)
	if not jumpPowerActive then return end
	if not humanoid or humanoid.Health <= 0 then return end
	if not hrp then return end
	local currentVel = hrp.AssemblyLinearVelocity
	if new == Enum.HumanoidStateType.Jumping then
		hrp.AssemblyLinearVelocity = Vector3.new(currentVel.X, jumpBoostForce, currentVel.Z)
	end
end
humanoid.StateChanged:Connect(applyJumpBoost)

-- ===== FOOTBALLS CACHE =====
local footballs = {}
local function updateFootballs()
	footballs = {}
	for _, v in ipairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") and v.Name == "Football" then
			footballs[#footballs+1] = v
		end
	end
end

task.spawn(function()
	while true do
		updateFootballs()
		task.wait(1)
	end
end)

-- ===== DO FIRE TOUCH =====
local function doFireTouch(ball, hand)
	if ball and hand then
		if not ball:IsDescendantOf(workspace) then 
			print("nah")
			return
		end
		if not hand:IsDescendantOf(workspace) then 
			print("nah")
			return
		end
		print("shouldcatch")
		firetouchinterest(ball, hand, 0)
		task.wait(1/60)
		firetouchinterest(ball, hand, 1)
	end
end


-- ===== TOGGLES =====

autoCatchBtn.MouseButton1Click:Connect(function()
	autoCatchActive = not autoCatchActive
	autoCatchBtn.Text = autoCatchActive and "MS ON" or "MS OFF"
	autoCatchBtn.BackgroundColor3 = autoCatchActive and Color3.fromRGB(24, 76, 36) or Color3.fromRGB(67, 0, 0)
end)

jumpToggleBtn.MouseButton1Click:Connect(function()
	jumpPowerActive = not jumpPowerActive
	jumpToggleBtn.Text = jumpPowerActive and "Jump Power ON" or "Jump Power OFF"
	jumpToggleBtn.BackgroundColor3 = jumpPowerActive and Color3.fromRGB(24, 76, 36) or Color3.fromRGB(67, 0, 0)
end)

-- ===== SPEED BOOST TOGGLE & INPUT (ADDED) =====
speedBoostBtn.MouseButton1Click:Connect(function()
	speedBoostActive = not speedBoostActive
	speedBoostBtn.Text = speedBoostActive and "Speed Boost ON" or "Speed Boost OFF"
	speedBoostBtn.BackgroundColor3 = speedBoostActive and Color3.fromRGB(24, 76, 36) or Color3.fromRGB(67, 0, 0)
end)

speedInputBox.FocusLost:Connect(function()
	local num = tonumber(speedInputBox.Text)
	if num then
		num = math.clamp(num, speedBoostMin, speedBoostMax)
		speedBoostForce = num
	end
	speedInputBox.Text = tostring(speedBoostForce)
end)

hitboxToggleBtn.MouseButton1Click:Connect(function()
	hitboxVisualActive = not hitboxVisualActive
	hitboxToggleBtn.Text = hitboxVisualActive and "Hitbox Visual ON" or "Hitbox Visual OFF"
	hitboxToggleBtn.BackgroundColor3 = hitboxVisualActive and Color3.fromRGB(24, 76, 36) or Color3.fromRGB(67, 0, 0)
end)

inputBox.FocusLost:Connect(function(enterPressed)
	local value = tonumber(inputBox.Text)
	if value then
		activationRange = clamp(value, 3, 10)
		inputBox.Text = tostring(activationRange)
	else
		inputBox.Text = tostring(activationRange)
	end
end)

jumpInputBox.FocusLost:Connect(function(enterPressed)
	local value = tonumber(jumpInputBox.Text)
	if value then
		jumpBoostForce = clamp(value, jumpBoostForceMin, jumpBoostForceMax)
		jumpInputBox.Text = tostring(jumpBoostForce)
	else
		jumpInputBox.Text = tostring(jumpBoostForce)
	end
end)

-- ===== STANDING + ANIMATION FIX FUNCTIONS (ADDED) =====
local function isStanding()
	if not humanoid then return false end

	local state = humanoid:GetState()
	return state == Enum.HumanoidStateType.Running
		or state == Enum.HumanoidStateType.RunningNoPhysics
		or state == Enum.HumanoidStateType.Landed
		or state == Enum.HumanoidStateType.GettingUp
end

local function isWalkOrRun(track)
	if not track.Animation then return false end
	local name = string.lower(track.Name)
	return name:find("walk") or name:find("run")
end

local function fixAnimationSpeed()
	if not humanoid then return end
	for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
		if track.IsPlaying and isWalkOrRun(track) then
			track:AdjustSpeed(1.57)
		end
	end
end
local currentrot = cardstrokeGradient.Rotation
local TweenService = game:GetService("TweenService")
local TweenInformation = TweenInfo.new(2, Enum.EasingStyle.Linear,Enum.EasingDirection.In,-1,false) 
local Goal = {Rotation = currentrot + 360}
local Tween = TweenService:Create(cardstrokeGradient, TweenInformation, Goal) 
local Tween2 = TweenService:Create(titleGradient, TweenInformation, Goal) 
local Tween3 = TweenService:Create(cardGradient, TweenInformation, Goal)

Tween:Play()
Tween2:Play()
Tween3:Play()

-- ===== HEARTBEAT LOOP =====
RunService.Heartbeat:Connect(function()
	if not hrp then return end

	-- AUTO CATCH
	if autoCatchActive and tick() - lastCatch >= 1/60 then
		for _, ball in ipairs(footballs) do
			if (ball.Position - hrp.Position).Magnitude <= activationRange then

				local handName = (math.random() < 0.5) and "CatchL" or "CatchR"
				local hand = player.Character:FindFirstChild(handName)
				print("in range")
				if hand then
					print("should catch")
					doFireTouch(ball, hand)
					lastCatch = tick()
				end
			end
		end
	end

	-- HITBOX VISUAL
	if hitboxVisualActive then
		for _, ball in ipairs(footballs) do
			if not hitboxParts[ball] then
				local sphere = Instance.new("Part")
				local model = Instance.new("Model", workspace)
				local newhum = Instance.new("Humanoid")
				newhum.Parent = model
				local highlight = Instance.new("Highlight")
				highlight.FillTransparency = 0.7
				highlight.FillColor = Color3.fromRGB(255, 0, 0)
				highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
				highlight.Parent = model
				highlight.Adornee = model
				highlight.Enabled = true
				highlight.DepthMode = Enum.HighlightDepthMode.Occluded
				sphere.Name = "CatchHitbox"
				sphere.Shape = Enum.PartType.Ball
				sphere.Material = Enum.Material.SmoothPlastic
				sphere.Anchored = true
				sphere.CanCollide = false
				sphere.CanTouch = false
				sphere.Size = Vector3.new(activationRange*2, activationRange*2, activationRange*2)
				sphere.Transparency = 0.99
				sphere.Color = Color3.fromRGB(255,0,0)
				sphere.Parent = model
				hitboxParts[ball] = sphere
			else
				local sphere = hitboxParts[ball]
				sphere.Size = Vector3.new(activationRange*2, activationRange*2, activationRange*2)
				sphere.CFrame = ball.CFrame
			end
		end
	end

	-- REMOVE HITBOXES IF BALL DESTROYED
	for ball, sphere in pairs(hitboxParts) do
		if not ball:IsDescendantOf(workspace) or ball.Parent ~= workspace or not hitboxVisualActive then
			if ball:FindFirstChild("Highlight") then
				ball.Highlight:Destroy()
			end
			sphere.Parent:Destroy()
			hitboxParts[ball] = nil
		end
	end

	-- ===== SPEED BOOST (ADDED) =====
	if speedBoostActive and humanoid and hrp then

		-- Disable during stun (WalkSpeed == 0)
		if humanoid.WalkSpeed == 0 then
			-- still keep animations fixed
			fixAnimationSpeed()
		else
			if isStanding() then
				local moveDir = humanoid.MoveDirection
				if moveDir.Magnitude > 0 then
					local vel = hrp.AssemblyLinearVelocity
					hrp.AssemblyLinearVelocity = Vector3.new(
						vel.X + moveDir.X * speedBoostForce,
						vel.Y,
						vel.Z + moveDir.Z * speedBoostForce
					)
				end
			end

			-- keep walk/run animation speed normal
			fixAnimationSpeed()
		end
	end
end)
